/*
题目描述
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

思路
负数用补码表示, 那么我们分三种情况讨论:

(1) n = 0, 有 0 个 1;

(2) n > 0, 正数最高位是 0, 把 n 和 1 作与运算, 如果 n 的最低位是 1, 运算结果为 1, 个数加一. 之后把 n 右移一位, 循环进行上述操作直到 n 为 0 结束.

(3) n < 0, 负数最高位是 1, 把最高位先置位成 0 , 个数加一, 再进行 (2) 的操作, 这是为了避免负数右移最高位会补 1, 导致结果不正确.11.二进制中1的个数

思路2
应该是最佳解法了, 无论代码长度还是复杂度.

如果一个整数不为 0, 那么这个整数至少有一位是 1. 如果我们把这个整数减 1, 那么原来处在整数最右边的 1 就会变为 0, 原来在 1 后面的所有的 0 都会变成 1 (如果最右边的 1 后面还有 0 的话). 其余所有位将不会受到影响.

举个例子: 一个二进制数 1100，从右边数起第三位是处于最右边的一个 1。减去 1 后，第三位变成 0，它后面的两位 0 变成了 1, 而前面的 1 保持不变, 因此得到的结果是 1011. 我们发现减 1 的结果是把最右边的一个 1 开始的所有位都取反了. 这个时候如果我们再把原来的整数和减去 1 之后的结果做与运算, 从原来整数最右边一个 1 那一位开始所有位都会变成 0. 如 1100 & 1011 = 1000.

也就是说, 把一个整数减去 1, 再和原整数做与运算, 会把该整数最右边一个 1 变成 0. 那么一个整数的二进制有多少个 1, 就可以进行多少次这样的操作.

也许你有疑惑: "那负数呢? 这段代码对补码表示的负数没有进行任何特殊处理呀!".

事实上, 上面所述的规则对于补码表示的负数也完全适用, 就算 INT_MIN 也不会发生错误. 因为 INT_MIN - 1 = INT_MAX.
*/
class Solution {
public:
     int  NumberOf1(int n) {
        int num = 0;
        if(n == 0)
                return 0;
        if(n > 0){
                int m;
                while(n){
                        m = n & 1;
                        if(m)
                                num++;
                        n >>= 1;
                }
                return num;
        }
        if(n < 0){
                n &= INT_MAX;
                num++;
                int m;
                while(n){
                        m = n & 1;
                        if(m)
                                num++;
                        n >>= 1;
                }
                return num;
        }
        return num;
     }
};
//思路2 代码
int  NumberOf1(int n) {
     int num = 0;
     while(n){
         num++;
         n &= (n-1);
     }
     return num;
}
//输出一个数的二进制的程序
#include <iostream>
#include <bitset>
using namespace std;

int main()
{
	int n;
	while(cin >> n){//输入一个数, 会给你输出它的二进制
		bitset<32> b(n);
		cout << b << endl;
	}
    return 0;
}
